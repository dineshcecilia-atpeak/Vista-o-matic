"use client";

import React, { useState, useRef, useEffect } from "react";

const HEATMAP_WIDTH = 640; // Width of the heatmap canvas
const HEATMAP_HEIGHT = 480; // Height of the heatmap canvas
const HEATMAP_SCALE = 20; // Scale factor for heatmap grid

const Heatmap: React.FC = () => {
  const [isWebcamActive, setWebcamActive] = useState(false);
  const [isHeatmapActive, setHeatmapActive] = useState(false);
  const [videoUrl, setVideoUrl] = useState<string | null>(null);
  const videoRef = useRef<HTMLVideoElement | null>(null);
  const canvasRef = useRef<HTMLCanvasElement | null>(null);

  useEffect(() => {
    let heatmapTimeout: NodeJS.Timeout | null = null;

    const renderLoop = () => {
      if (
        videoRef.current &&
        canvasRef.current &&
        (isWebcamActive || videoUrl) &&
        videoRef.current.readyState === videoRef.current.HAVE_ENOUGH_DATA
      ) {
        const ctx = canvasRef.current.getContext("2d");
        if (ctx && isHeatmapActive) {
          renderHeatmap(ctx);
        }
      }
      heatmapTimeout = setTimeout(() => requestAnimationFrame(renderLoop), 100); // Render every 100 ms
    };

    if (isWebcamActive || videoUrl) {
      renderLoop();
    }

    return () => {
      if (heatmapTimeout) clearTimeout(heatmapTimeout);
    };
  }, [isWebcamActive, isHeatmapActive, videoUrl]);

  const toggleWebcam = async () => {
    if (navigator.mediaDevices && !isWebcamActive) {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        if (videoRef.current) {
          videoRef.current.srcObject = stream;
          videoRef.current.play();
        }
        setWebcamActive(true);
      } catch (error) {
        console.error("Error accessing webcam:", error);
        alert("Failed to access the webcam. Please check your camera permissions.");
      }
    } else {
      stopPlayback();
    }
  };

  const stopPlayback = () => {
    if (videoRef.current) {
      if (videoRef.current.srcObject) {
        const stream = videoRef.current.srcObject as MediaStream;
        stream.getTracks().forEach((track) => track.stop());
      }
      videoRef.current.srcObject = null;
      videoRef.current.pause();
      videoRef.current.currentTime = 0;
    }
    setWebcamActive(false);
    setVideoUrl(null); // Clear the uploaded video URL
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      const videoUrl = URL.createObjectURL(file);
      if (videoRef.current) {
        videoRef.current.onloadedmetadata = () => {
          videoRef.current?.play();
          setVideoUrl(videoUrl);
        };
        videoRef.current.src = videoUrl;
      }
      stopPlayback(); // Ensure the webcam stops when a file is loaded
    }
  };

  const detectMovement = (pixels: Uint8ClampedArray) => {
    const heatmapData: number[][] = Array.from({ length: HEATMAP_HEIGHT / HEATMAP_SCALE }, () =>
      Array(HEATMAP_WIDTH / HEATMAP_SCALE).fill(0)
    );

    for (let y = 0; y < HEATMAP_HEIGHT; y += HEATMAP_SCALE) {
      for (let x = 0; x < HEATMAP_WIDTH; x += HEATMAP_SCALE) {
        const pixelIndex = (y * HEATMAP_WIDTH + x) * 4;
        const red = pixels[pixelIndex];
        const green = pixels[pixelIndex + 1];
        const blue = pixels[pixelIndex + 2];

        const brightness = (red + green + blue) / 3;
        if (brightness < 100) {
          const gridX = Math.floor(x / HEATMAP_SCALE);
          const gridY = Math.floor(y / HEATMAP_SCALE);
          heatmapData[gridY][gridX]++;
        }
      }
    }
    return heatmapData;
  };

  const renderHeatmap = (ctx: CanvasRenderingContext2D) => {
    if (!videoRef.current) return;
  
    const videoCanvas = document.createElement("canvas");
    videoCanvas.width = HEATMAP_WIDTH;
    videoCanvas.height = HEATMAP_HEIGHT;
    const videoCtx = videoCanvas.getContext("2d");
  
    if (videoCtx) {
      videoCtx.drawImage(videoRef.current, 0, 0, HEATMAP_WIDTH, HEATMAP_HEIGHT);
      const frameData = videoCtx.getImageData(0, 0, HEATMAP_WIDTH, HEATMAP_HEIGHT);
      const heatmapData = detectMovement(frameData.data);
  
      ctx.clearRect(0, 0, HEATMAP_WIDTH, HEATMAP_HEIGHT);
  
      heatmapData.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value > 0) {
            let fillColor;
            if (value <= 10) {
              fillColor = `rgba(0, 255, 0, 0.8)`; // Green
            } else if (value > 10 && value <= 30) {
              fillColor = `rgba(255, 255, 0, 0.8)`; // Yellow
            } else {
              fillColor = `rgba(255, 0, 0, 0.8)`; // Red
            }
  
            ctx.fillStyle = fillColor;
            ctx.fillRect(x * HEATMAP_SCALE, y * HEATMAP_SCALE, HEATMAP_SCALE, HEATMAP_SCALE);
          }
        });
      });
    }
  };
  
  return (
    <div className="container mx-auto p-6 rounded-lg grid grid-cols-2 gap-4">
      <div className="bg-[#011221] rounded-lg p-6 border border-gray-600 flex flex-col">
        <h2 className="text-2xl font-bold text-white mb-4">Live Analytics</h2>
        <div className="mb-4 flex space-x-4">
          <button
            className={`px-4 py-2 rounded ${
              isWebcamActive ? "bg-red-500 text-white" : "bg-yellow-500 text-black"
            }`}
            onClick={toggleWebcam}
          >
            {isWebcamActive ? "Stop Webcam" : "Start Webcam"}
          </button>
          <input
            type="file"
            accept="video/*"
            onChange={handleFileChange}
            className="bg-yellow-500 text-black px-4 py-2 rounded"
          />
        </div>
        <div className="video-container bg-[#00142a] rounded-lg p-4 border border-gray-600">
          <video ref={videoRef} className="w-full h-full object-cover" autoPlay muted />
          {!isWebcamActive && !videoUrl && (
            <p className="text-white text-center mt-4">Webcam feed or video will appear here once started.</p>
          )}
        </div>
      </div>
      <div className="bg-[#011221] rounded-lg p-6 border border-gray-600 flex flex-col">
        <h2 className="text-2xl font-bold text-white mb-4">Heatmap</h2>
        <p className="text-[#e4cfa1] text-center">
          Heatmap visualization will appear here when enabled.
        </p>
        <div className="flex justify-center">
          <button
            className={`px-4 py-2 rounded ${
              isHeatmapActive ? "bg-red-500" : "bg-green-500"
            } mt-4`}
            onClick={() => setHeatmapActive(!isHeatmapActive)}
          >
            {isHeatmapActive ? "Disable Heatmap" : "Enable Heatmap"}
          </button>
        </div>
        {isHeatmapActive && (
          <canvas
            ref={canvasRef}
            width={HEATMAP_WIDTH}
            height={HEATMAP_HEIGHT}
            className="w-full h-full mt-4 border border-gray-600"
          />
        )}
      </div>
    </div>
  );
};

export default Heatmap;
